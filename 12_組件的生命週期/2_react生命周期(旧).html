<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- 移動端適配 -->
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>2_react生命周期(旧)</title>
</head>
  <body>
  <!-- 準備好一個 "容器" -->
  <!-- 必須要按順序引入！！！！核心庫就位了，才可以把擴展庫引用，否則使用不了  -->
  <div id="test"></div>

  <!-- 引入 react 核心庫 -->
  <script type="text/javascript" src="../js/react.development.js"></script>
  <!-- 引入 react-dom. 用於支持 react 操作 DOM -->
  <script type="text/javascript" src="../js/react-dom.development.js"></script>
  <!-- 引入 babel, 用於將 jsx 專為 js -->
  <script type="text/javascript" src="../js/babel.min.js"></script>

  <script type="text/babel"> // 該部分一定要寫 babel 是表示裡面寫的不再是 js, 而是 jsx
  /*
   1. 初始化阶段: 由ReactDOM.render()触发---初次渲染
1.	constructor()
2.	componentWillMount()
3.	render()
4.	componentDidMount(）====》常用
- 一般在這個鉤子中做一些初始化的事，例如：開啟定時器，發送網絡請求，訂閱消息

	2. 更新阶段: 由组件内部this.setSate()或父组件重新render触发
1.	shouldComponentUpdate()
2.	componentWillUpdate()
3.	render()
4.	componentDidUpdate() ====》 必須使用的一個

	3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发
1.	componentWillUnmount() =====》常用
- 一般在這個鉤子中做一些收尾的事，例如：關閉定時器，取消訂閱消息

   */

  // 1. 創建组件
  class Count extends React.Component{

      //構造器
      constructor(props){ // 構造器是做初始化的東西
          console.log('Count---constructor');
          super(props)
          //初始化狀態
          this.state = {count:0}
      }

      
      
      //加 1 按鈕的回調
      add = ()=>{
          //獲取原狀態
          const {count} = this.state
          //更新狀態
          this.setState({count:count+1})
      }

      //卸載組件按鈕的回調
      death = ()=>{
          ReactDOM.unmountComponentAtNode(document.getElementById('test')) //卸載組件
      }

      //強制更新按鈕的回調
      force = ()=>{
          this.forceUpdate()
      }

      //組件將要掛載的鉤子
      componentWillMount(){
          console.log('Count---componentWillMount');
      }

      //組件掛載完畢的鉤子
      componentDidMount(){
          console.log('Count---componentDidMount');
      }

      //組件將要卸載的鉤子
      componentWillUnmount(){
          console.log('Count---componentWillUnmount');
      }

      //控制組件更新的‘閥門’，開啟該步驟才可以繼續向下一個步驟運行
      shouldComponentUpdate(){
          console.log('Count---shouldComponentUpdate');
          return true
      }

      //組件將要更新的鉤子
      componentWillUpdate(){ //比較少用
        console.log('Count---componentWillUpdate');
      }

      //組件更新完畢的鉤子
      componentDidUpdate(){
        console.log('Count---componentDidUpdate');
      }

      render(){
          console.log('Count---render');
          const{count} = this.state
          return(
              
              <div>
              <h2>當前求和為: {count}</h2>
              <button onClick={this.add}>點我+1</button>
              <button onClick={this.death}>卸載組件</button>
              <button onClick={this.force}>不更改任何狀態中的數據，強制更新一下</button>
              </div>
          )
      }
  }

  //父组件A
  class A extends React.Component{
      //初始化狀態
      state = {carName: '奔馳'}

      changeCar = ()=>{
          this.setState({carName:'奧迪'})
      }
      
      render(){
          return(
        <div>
          <div>我是A組件</div>
          <button onClick={this.changeCar}>換車</button> 
          {/** 當點擊換車就會調用  changeCar
          changeCar = ()=>{
          this.setState({carName:'奧迪'})
      }
      調用後就會更改了 A組件的狀態，就導致了 A 組件調用了 render
      而 A 調用的 render 就是圖片所說的 副組件render
      而第二次render就可以稱為副組件重新render
      而第二次render就會運行到 <B carName={this.state.carName}/> 
      而該代碼重新執行，B組件的render就會重新調用，來傳遞一個新的值 {this.state.carName}
      所以會導致第二次接收 props
          */}
          <B carName={this.state.carName}/>
        </div>
      )
    }
  }

  //子组件B
  class B extends React.Component{
      //組件將要接收新的 props 的鉤子
      componentWillReceiveProps(props){ //它可以接收參數 props
          console.log('B---componentWillReceiveProps',props);
      }

      //控制組件更新的‘閥門’，開啟該步驟才可以繼續向下一個步驟運行
      shouldComponentUpdate(){
          console.log('B---shouldComponentUpdate');
          return true
      }

      //組件將要更新的鉤子
      componentWillUpdate(){ //比較少用
        console.log('B---componentWillUpdate');
      }

      //組件更新完畢的鉤子
      componentDidUpdate(){
        console.log('B---componentDidUpdate');
      }

      render(){
          console.log('B---render');
          return(
          <div>我是B組件，接收到的車是:{this.props.carName}</div>
      )
    }
  }

  //渲染組件
  ReactDOM.render(<A/>,document.getElementById('test'))
  </script>
  </body>
</html>